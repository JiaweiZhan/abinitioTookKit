#!/scratch/midway2/jiaweiz/anaconda3/bin/python3
import numpy as np
from tqdm import tqdm
import argparse
import utils
import threading
import os, shutil
import signal

store = False
storeFolders = []

def handler(signum, frame):
    # handler for handle ctrl-C
    print("", end="\r", flush=True)
    print("clean store file", flush=True)
    if store:
        for path in storeFolders:
            shutil.rmtree(path)
    exit(1)

if __name__ == "__main__":

    signal.signal(signal.SIGINT, handler)
    # -----------------------------------------------------------------------------
    utils.time_now()

    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--save_folder", type=str,
            help="*.save folder generated by QE. Default: ./scf.save")
    parser.add_argument("-d", "--delta", type=float,
            help="delta that control local VB/CB. Default: 0.001")
    parser.add_argument("-t", "--thread", type=int,
            help="num of thread. Default: max_thread - 1")
    parser.add_argument("-b", "--backup", type=int,
            help="store wfc on disk 1 or not 0 (store in memory). Default: 0")
    args = parser.parse_args()

    # default values
    if not args.save_folder:
        args.save_folder = "./scf.save"
    assert(os.path.exists(args.save_folder))
    if not args.thread:
        # get the number of logical cpu cores
        n_cores = int(os.cpu_count())
        args.thread = n_cores - 1 
    if not args.delta:
        args.delta = 0.001 
    if not args.backup:
        args.backup = 0 

    if args.backup == 1:
        store = True 

    utils.delta = args.delta

    print(f"configure:\
            \n {''.join(['-'] * 41)}\
            \n{'QE save folder':^20}:{args.save_folder:^20}\
            \n{'delta':^20}:{args.delta:^20}\
            \n{'threads':^20}:{args.thread:^20}\
            \n {''.join(['-'] * 41)}\n\
            ")

    # -----------------------------------------------------------------------------
    xml_file = args.save_folder + '/data-file-schema.xml'
    wfc_files = [args.save_folder + '/' + file for file in os.listdir(args.save_folder) if 'wfc' in file]

    xml_data = utils.parse_QE_XML(xml_file)
    # num of occupied bands
    nks = xml_data['nks']
    nspin = xml_data['nspin']
    utils.numOcc = xml_data['occ']   # [nspin * nks * nbnds]
    utils.kWeights = xml_data['kweights']
    utils.tot_bands = xml_data['nbnd']
    utils.eigens = xml_data['eigen'] # [nspin * nks * nbnds]
    fft_grid = xml_data['fftw']
    fft_grid = np.array(fft_grid) // 2 + 1

    utils.ksStateZAve = np.zeros((nspin, nks, utils.tot_bands, fft_grid[2]))
    for index in range(nks * nspin):
        wfc_data = utils.parse_QE_wfc(wfc_files[index])
        ik = wfc_data['ik']
        ispin = wfc_data['ispin']
        print(f"ik: {ik}, ispin: {ispin}, nbnd: {wfc_data['nbnd']}, npol: {wfc_data['npol']}, igwx: {wfc_data['igwx']}")

        # store and read
        if args.backup == 1:
            storeFolder = wfc_files[index].split('/')[-1].split('.')[0]
            storeFolders.append(storeFolder)
            utils.storeGvec(xml_data, wfc_data, Store=True, storeFolder=storeFolder, threadNum=args.thread)
            wfcStored = os.listdir(storeFolder)
            for fileName in tqdm(wfcStored, desc='read wfc from stored file'):
                wfcName = storeFolder + '/' + fileName
                ibnd = int(fileName.split('.')[0].split('_')[-1])
                evc_r = np.load(wfcName)
                utils.ksStateZAve[ispin - 1, ik - 1, ibnd - 1, :] = np.sum(np.absolute(evc_r) ** 2, axis=(0, 1,))
            shutil.rmtree(storeFolder)
        else:
            # direct comput and store in memory
            evc_r = utils.storeGvec(xml_data, wfc_data, Store=False)
            utils.ksStateZAve[ispin - 1, ik - 1, :, :] = np.sum(np.absolute(evc_r) ** 2, axis=(1, 2,))
        print('\n')

    utils.lcbm = np.zeros(fft_grid[2])
    utils.lvbm = np.zeros(fft_grid[2])
    #define lock and condition
    utils.lock_list = threading.Lock()
    utils.condition_list = threading.Condition(utils.lock_list)

    num_thread = args.thread
    length_chunk = fft_grid[2] / num_thread
    a_axis_tot = list(range(fft_grid[2]))

    utils.lock_list.acquire()
    for i in range(num_thread):
        utils.z_axis_assign.append(a_axis_tot[int(i * length_chunk) : int((i + 1) * length_chunk)])

    # poison
    utils.z_axis_assign.append([])
    utils.condition_list.notify_all()
    utils.lock_list.release()

    # start thread
    threads = []
    ids = []
    for i in range(num_thread):
        ids.append(i)
        thread_id = threading.Thread(target=utils.ldos_worker, args = (ids[i],))
        threads.append(thread_id)

    for thread_id in threads:
        thread_id.start()

    for thread_id in threads:
        thread_id.join()
    # thread end
    with open('ldos.txt', 'w') as file_object:
        file_object.writelines("LVBM:\n")
        for i in range(fft_grid[2]):
            file_object.write(f'{utils.lvbm[i]:12.5f}')
            if i % 5 == 4:
                file_object.write('\n')
        file_object.write('\n\n')
        file_object.writelines("LCBM:\n")
        for i in range(fft_grid[2]):
            file_object.write(f'{utils.lcbm[i]:12.5f}')
            if i % 5 == 4:
                file_object.write('\n')
